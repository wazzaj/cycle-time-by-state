<!DOCTYPE html>
<html>
<head>
    <title>cycletimebystate</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/async/1.22/async.min.js"></script>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc1/lib/analytics/analytics-all.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.3.1/moment.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                var app = null;

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    
    // kanbanField : "c_KanbanState",
    // kanbanField : "c_KanbanBoardOperation",
    // finalValue : "Done",
    
    launch: function() {
        //Write app code here
        console.log("launch");
        app = this;
        // this.startDate = moment().startOf('month').toISOString();
        // this.startDate = moment().subtract('month',6).toISOString();
        this.startDate = moment().subtract('month',app.getSetting("months")).toISOString();

        if ((app.getSetting("type") === "") &&
            (app.getSetting("stateField") === "") &&
            (app.getSetting("finalValue") === "")) {
            this.createUI();
        } else {
            app.type = app.getSetting("type");
            app.kanbanField = app.getSetting("stateField");
            app.finalValue  = app.getSetting("finalValue");
        }

        var panel = Ext.create('Ext.container.Container', {
            itemId : 'panel',
            title: 'Hello',
            width: 800,
            height: 600,
            html: '<p></p>'
        });

        this.add(panel);
        var p = this.down("#panel");
        app.jqPanel = "#"+p.id;

        if (!((app.getSetting("stateField") === "") &&
            (app.getSetting("finalValue") === ""))) {
            app.run();
        }

    },

    config: {

    defaultSettings : {

        type : "",
        stateField : "",
        finalValue : "",
        timeInHours : false,
        months : 6,
        queryField : "",
        queryValue : ""
        }
    },

    getSettingsFields: function() {
        var values = [
            {
                name: 'type',
                xtype: 'rallytextfield',
                label : "Comma delimited list of types eg. Story,Defect or PortfolioItem/Feature"
            },

            {
                name: 'stateField',
                xtype: 'rallytextfield',
                label : "Field name cycle time calculation is based on eg. State"
            },
            {
                name: 'finalValue',
                xtype: 'rallytextfield',
                label: 'Filter items that have moved into this state eg. Closed or Accepted'
            },
            {
                name: 'timeInHours',
                xtype: 'rallycheckboxfield',
                label: 'Show cycle time values in hours (instead of days)'
            },
            {
                name: 'months',
                xtype: 'rallytextfield',
                label: 'Number of months to consider'
            },            
            {
                name: 'queryField',
                xtype: 'rallytextfield',
                label: 'Additional field to filter results on'
            },            
            {
                name: 'queryValue',
                xtype: 'rallytextfield',
                label: 'Value of additional field used to filter results on'
            }

        ];

        return values;
    },


    run : function () {

        app.mask = new Ext.LoadMask(Ext.getBody(), {msg:"Please wait..."});
        app.mask.show();
        
        async.waterfall([   
            app.getCompletedItems,
            app.getSnapshotsForCompletedItems,
            app.getProjectNamesForCompletedItems,
            app.prepareSnapshots,
            app.pivotData
            ], 
            function( err, results ) {
                app.mask.hide();
            }
        );
    },
    
    createUI : function() {
        
        var createButton = function() {
            if (app.goButton)
                app.goButton.destroy();
            app.goButton = Ext.create("Rally.ui.Button", {
                margin : 5,
                height : 20,
                text : "Go",
                handler: function() {
                    console.log("fieldCombo:",app.fieldCombo.getValue());
                    console.log("valueCombo:",app.valueCombo.getValue());
                    app.kanbanField = app.fieldCombo.getValue()
                    app.finalValue  = app.valueCombo.getValue()
                    app.run();
                }
            });
            app.boxcontainer.add(app.goButton);
            
        };
        
        var createValueCombo = function(valuefield) {
            if (app.valueCombo)
                app.valueCombo.destroy();
            
            app.valueCombo = Ext.create("Rally.ui.combobox.FieldValueComboBox", {
                padding : 5,
                
                stateful : true, stateId : "Rally.ui.combobox.FieldValueComboBox",
                model: 'UserStory',
                field: valuefield,
                listeners : {
                    ready : function(t) {
                        console.log("value ready",t.getValue());
                        if (t.getValue()!=="")
                            createButton();
                    },
                    select : function(a,selected,c) {
                        console.log("selected",selected[0].get("value"));
                        createButton();
                    }
                }
            });
            return app.valueCombo;
        };
        
        app.fieldCombo = Ext.create('Rally.ui.combobox.FieldComboBox', {
            padding : 5,
            stateful : true, stateId : "Rally.ui.combobox.FieldComboBox",
            model: 'UserStory',
            listeners : {
                ready : function(t,e) {
                    createValueCombo(t.getValue());
                    app.boxcontainer.add(app.valueCombo);
                },
                select : function(a,selected,c) {
                    console.log("selected",selected);
                    createValueCombo(selected[0].get("value"));
                    if (app.goButton) app.goButton.destroy();
                    app.boxcontainer.add(app.valueCombo);
                }
            }
        });
        
        app.boxcontainer = Ext.create('Ext.container.Container', {
            itemId : "container",
            layout: { type: 'hbox'},
            width: 400,
            border: 1,
            style: {borderColor:'#000000', borderStyle:'solid', borderWidth:'1px'},
            // padding : 5
        });
        app.boxcontainer.add(app.fieldCombo);
        this.add(app.boxcontainer);
        
    },

    getTypes : function() {

        var types = _.map( app.type.split(","), function(t) {
            return t.toUpperCase() !== "STORY" ? t : "HierarchicalRequirement";
        });
        console.log("types:",types);
        return types;
    },
    
    // reads the snapshots for items that have been completed since the specified start date.
    getCompletedItems : function( callback ) {
        
        var that = this;

        var fetch = ['FormattedID','ObjectID','_TypeHierarchy','_PreviousValues','PlanEstimate','Project',app.kanbanField];
        var hydrate = ['_TypeHierarchy',app.kanbanField];
        
        var find = {
                // '_TypeHierarchy' : { "$in" : ["HierarchicalRequirement","Defect"]} ,
                '_TypeHierarchy' : { "$in" : app.getTypes() } ,
                '_ProjectHierarchy' : { "$in": [app.getContext().getProject().ObjectID] },
                // 'Children' : { "$exists" : false}
        };
        // for stories only include child level items
        if ( _.findIndex(app.getTypes(),function(t){
            return t.toUpperCase()==="HIERARCHICALREQUIREMENT";
        }) !== -1) {
            find['Children'] = { "$exists" : false}
        }

        find[app.kanbanField] =  app.finalValue;
        find["_PreviousValues."+app.kanbanField] =  {"$ne" : null };
        find["_ValidFrom"] = { "$gte" : app.startDate };

        var storeConfig = {
            find : find,
            autoLoad : true,
            pageSize:1000,
            limit: 'Infinity',
            fetch: fetch,
            hydrate: hydrate,
            listeners : {
                scope : this,
                load: function(store, snapshots, success) {
                    console.log("success",success);
                    console.log("completed snapshots:", snapshots.length);
                    console.log("unique completed   :", _.uniq(_.map(snapshots,function(s){return s.get("ObjectID");})).length);
                    callback(null,snapshots);
                }
            }
        };

        var snapshotStore = Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);
        
    },

    // will process the snapshots adding additional elements
    prepareSnapshots : function(completedItems, snapshots,callback) {

        _.each(snapshots, function(s) {
            // set the month
            var ci = _.find(completedItems,function(c) { return c.get("ObjectID") === s.get("ObjectID");});
            var month = moment(ci.get("_ValidFrom")).format ("MMM YYYY");
            s.set("CompletedDate",ci.get("_ValidFrom"));
            s.set("Month",month);
            s.set("Size",ci.get("PlanEstimate"));
        });

        callback( null, completedItems, snapshots );

    },

    pivotData : function( completedItems, snapshots, callback ) {

        var addCommas = function(nStr) {
            var rgx, x, x1, x2;
            nStr += '';
            x = nStr.split('.');
            x1 = x[0];
            x2 = x.length > 1 ? '.' + x[1] : '';
            rgx = /(\d+)(\d{3})/;
            while (rgx.test(x1)) {
              x1 = x1.replace(rgx, '$1' + ',' + '$2');
            }
            return x1 + x2;
          };

        var numberFormat = function(sigfig, scaler) {
            if (sigfig == null) {
              sigfig = 3;
            }
            if (scaler == null) {
              scaler = 1;
            }
            return function(x) {
              if (x === 0 || isNaN(x) || !isFinite(x)) {
                return "";
              } else {
                return addCommas((scaler * x).toFixed(sigfig));
              }
            };
        };

        var cycleTime = function() {

          return function(x,y,z) {
            var xx = x;
            var yy = y;
            var zz = z;
            return {
              recs : [],

              push: function(record) {
                this.recs.push(record);
                // return this.count++;
                return this.recs.length;
              },
              value: function(value) {
                console.log("Records for:",yy,zz);
                // console.log("calculating cycle time for #records:",this.recs.length);
                // console.log("#records:",this.recs);
                var ct = (calcCyleTime(this.recs));
                // console.log("ct",ct);
                console.log("#ids",_.pluck(ct,"FormattedID"));
                console.log("#cycletimes",_.pluck(ct,"ticks"));
                var mean = _.mean( _.pluck(ct,"ticks"));
                var median = _.median( _.pluck(ct,"ticks"));
                var max = _.max( _.pluck(ct,"ticks"));
                var min = _.min( _.pluck(ct,"ticks"));
                var cnt = _.pluck(ct,"ticks").length;
                var stddev = _.stdDeviation(_.pluck(ct,"ticks"));
                var cov = (mean!==0) ?stddev / mean : 0;
                mean = parseFloat(Math.round(mean * 100) / 100).toFixed(2);
                median = parseFloat(Math.round(median * 100) / 100).toFixed(2);
                stddev = parseFloat(Math.round(stddev * 100) / 100).toFixed(2);
                cov    = parseFloat(Math.round(cov * 100) / 100).toFixed(2);

                console.log("cnt/mean/median/max/min/stddev/cov",cnt,",",mean,",",median,",",max,",",min,",",stddev,",",cov);
                return mean
              },
              format: numberFormat(0),
              label: "cycleTime"
            };
          };
        };

        var calcCyleTime = function( snapshots ) {
                // console.time("cycle-time");
                var that = this;
                // var granularity = 'day';
                var granularity = app.getSetting("timeInHours") === false ? 'day' : 'hour';
                var tz = 'America/New_York';
                
                var config = { //  # default work days and holidays
                    granularity: granularity,
                    tz: tz,
                    validFromField: '_ValidFrom',
                    validToField: '_ValidTo',
                    // uniqueIDField: 'ObjectID',
                    uniqueIDField: 'FormattedID',
                    workDayStartOn: {hour: 13, minute: 0}, // # 09:00 in Chicago is 15:00 in GMT
                    workDayEndBefore: {hour: 22, minute: 0} // # 11:00 in Chicago is 17:00 in GMT  # 
                };
                
                // var start = moment().dayOfYear(0).toISOString();
                var start = moment().subtract(1, 'years').toISOString();
                var end =   moment().toISOString();
                var tisc = null;
                if (_.isUndefined(window.parent._lumenize)) {
                    tisc = new window._lumenize.TimeInStateCalculator(config);
                } else {
                    tisc = new window.parent._lumenize.TimeInStateCalculator(config);
                }
                tisc.addSnapshots(snapshots, start, end);
                var results = tisc.getResults();
                console.timeEnd("cycle-time");
                // callback(null,results);
                return results;
        };

        var teamNameDeriver = function(record) {

            var p = _.find(app.projects, function(f) { return record.Project === f.get("ObjectID");});

            return p ? p.get("Name") : record.Project;

        };

        var completedDateDeriver = function(record) {
            return moment(record.CompletedDate).format ("MMM YYYY");
        }

        var data = _.map(snapshots,function(s) { 
            return s.data;
        });

        $(app.jqPanel).pivotUI(
            data,                    
            {
                derivedAttributes : { "Team" : teamNameDeriver, "MonthCompleted" : completedDateDeriver },
                aggregators : { cycleTime : cycleTime },
                rows: [app.kanbanField],
                cols: ["Team"],
                hiddenAttributes : ["PlanEstimate", "ObjectID","_TypeHierarchy","_UnformattedID","_ValidFrom","_ValidTo","Project","CompletedDate"]
            }
        );
        
        callback( null, completedItems, snapshots );
    },

    readSnapshots : function( config, callback) {
        console.log("reading page of snapshots...");
         var storeConfig = {
            find : config.find,
            autoLoad : true,
            pageSize:1000,
            limit: 'Infinity',
            fetch: config.fetch,
            hydrate: config.hydrate,
            listeners : {
                scope : this,
                load: function(store, snapshots, success) {
                    callback(null,snapshots);
                }
            }
        };
        var snapshotStore = Ext.create('Rally.data.lookback.SnapshotStore', storeConfig);
    },

    getProjectNamesForCompletedItems : function(completedItems,snapshots,callback) {

        var projectOids = _.uniq(_.pluck( snapshots, function(c) { return c.get("Project");}) );
        console.log("Distinct Project IDs:",projectOids);

        var configs = _.map(projectOids, function(p) {
            return {
                    model : "Project",
                    fetch : ["Name","ObjectID","FormattedID"],
                    filters : [{property:"ObjectID",value:p}]
                };
        });

        async.map(configs,app.wsapiQuery,function(err,results) {

            app.projects = _.flatten(results);

            // remove snapshots where the project was not found (out of scope, closed etc.)
            var filteredSnapshots = _.filter(snapshots,function(s) {
                var p = _.find( app.projects, function(p) { 
                    return s.get("Project")===p.get("ObjectID");
                });
                return !_.isUndefined(p) && !_.isNull(p);
            });

            console.log("projects:",app.projects);
            // pass on to next function in the chain.
            callback(null,completedItems,filteredSnapshots);

        });

    },
    
    getSnapshotsForCompletedItems : function(completedItems,callback) {

        var that = this;

        var completedOids = _.uniq( _.pluck( completedItems, function(c) { return c.get("ObjectID"); } ));        
        console.log("oids",completedOids.length);

        var oidsArrays = [];
        var i,j,chunk = 50;
        for (i=0, j=completedOids.length; i<j; i+=chunk) {          
            oidsArrays.push(completedOids.slice(i,i+chunk));
        }
        console.log("oidsArrays",oidsArrays);

        var configs = _.map( oidsArrays, function(oArray) {
            return {
                fetch : ['FormattedID','_UnformattedID','ObjectID','_TypeHierarchy','PlanEstimate', 'ScheduleState',app.kanbanField],
                hydrate : ['_TypeHierarchy','ScheduleState',app.kanbanField],
                find : {
                    // '_TypeHierarchy' : { "$in" : ["HierarchicalRequirement","Defect"]} ,
                    '_TypeHierarchy' : { "$in" : app.getTypes() } ,
                    '_ProjectHierarchy' : { "$in": [app.getContext().getProject().ObjectID] }, 
                    'ObjectID' : { "$in" : oArray }
                }
            }
        })

        async.mapSeries( configs, app.readSnapshots, function(err,results) {

            var snapshots = [];
            _.each(results,function(r) {
                snapshots = snapshots.concat(r);
            });
            console.log("total snapshots",snapshots.length);
            callback(null,completedItems,snapshots)

        });


    }, 
    
    summarizeResults : function( stateResults, callback ) {
      
        _.each(stateResults, function(result) {
            
            var resultTicks = _.pluck(result.results, function(r) { return r.ticks; });
            result.min = _.min( resultTicks ) ;
            result.max = _.max( resultTicks );
            result.avg = _.reduce(resultTicks, function(memo, num) {
        		    return memo + num;
                }, 0) / resultTicks.length;
                
            result.median = _.median( _.sortBy(resultTicks) , function(r) { return r;});
            result.mean   = _.mean( resultTicks , function(r) { return r;});
            result.ticks = _.sortBy(resultTicks);
        });
        callback(null,stateResults);
        
    },
    
    wsapiQuery : function( config , callback ) {
        Ext.create('Rally.data.WsapiDataStore', {
            autoLoad : true,
            limit : "Infinity",
            model : config.model,
            fetch : config.fetch,
            filters : config.filters,
            // context: config.context,
            listeners : {
                scope : this,
                load : function(store, data) {
                    callback(null,data);
                }
            }
        });
    }

});

                (function () {
  
  function mixin_loader(lodash) {
    var math = this.math = {};
    if(lodash === undefined) {    
      lodash = require('lodash').runInContext();
    }
   
    function objKey2Array(obj,key) {
      var arr;
      if (lodash.isArray(obj) && typeof obj[0] === 'number') {
        arr = obj;
      } else {
        key = key || 'value';
        arr = lodash.pluck(obj, key);
      }
      return arr;
    }
    
    math.weightedAverage = function(values,weights) {
      var weightSum=lodash.sum(weights);
      weights = lodash.map(weights,function(weight) {
        return weight/weightSum;
      });
      return lodash.sum(
              lodash.map(
               lodash.zip(values,weights),
               function(pair) {
                return pair[0]*pair[1];
               }));
    };
    
    // Product
    // math.product([1,2,3,4,5,6])
    //   => 720 aka 6!
    math.product = function(obj, key) {
      var arr=objKey2Array(obj, key),
       product=1;
      for(var i=0;i<arr.length;++i) {
        product*=arr[i];
      }
      return product;
    };

    // Greatest common divisor
    // math.gcd([4,6,12])
    //   => 2
    math.gcd = function(obj, key) {
      var arr = objKey2Array(obj, key);
      if(arr.length == 2) {
        var n=arr[0],
         m=arr[1];
        if (n === 0) {
          return m;
        }
        while (m) {if (n > m) {n -= m;} else {m -= n;}}
        return n;
      }
      else {
        var arrCopy=arr.slice();
        return math.gcd(arrCopy.splice(0,1),arr);
      }
    };
    
    // Least common multiple
    // math.lcm([3,4,2])
    //   => 12
    math.lcm = function(obj, key) {
      var array = objKey2Array(obj, key),
       n = array.length,
       a = Math.abs(array[0]);
      for(var i = 1; i < n; ++i) {
        var b = Math.abs(array[i]),
         c = a;
        while (a && b) {
          if(a > b) {
            a%=b;
          }
          else {
            b%=a;
          }
        }
        a = Math.abs(c * array[i]) / (a + b);
      }
      return a;
    };
    
    // Arithmetic mean
    // math.mean([1,2,3])
    //   => 2
    math.mean = math.ave = math.average = function(obj, key) {
      try { 
        return internalSum(obj, key) / lodash.size(obj);
      }
      catch(e) {
        //Overflow or underflow.  Let's break things up a bit
        var arr = objKey2Array(obj,key);
        if(arr.length<4) {
          //Breaking things down further won't help if we are chunking the way we are.
          //We need to do this manually;
          if(arr.length === 2) {
            //We are down to two numbers and those two numbers can't be summed.
            //How to average numbers without summing and using the alu less.
            return arr[0]+(arr[1]-arr[0])/2;
          }
          if(arr.length === 3) {
            //Reducing alu usage is not so easy with three.
            return arr[0]/3 + arr[1]/3 + arr[2]/3;
          }
        }
        //To simplify things we need to chunk this thing as a mutiple of the length (no remainder at end) so we don't need weighted averages.
        //To reduce the likelyhood of another overflow we want to get close to the square root of the length.
        //This minimizes the largest grouping we have to average.
        var chunkSize=Math.ceil(Math.sqrt(arr.length));
        while(arr.length % chunkSize) {
          --chunkSize;
        }
        if(chunkSize != 1) {
          return math.mean(
                  lodash.map(
                   lodash.chunk(arr, chunkSize),
                   math.mean));
        }
        else {
          //We have a prime length.  We can't break it into multiple even chunks other than of length one which gets us nowhere.
          //We need to do a weighted average of smaller sets;
          //For now split the array in roughly two and take a weighted average of their averages.
          //Copy arr
          var arrCopy = arr.concat();
          //Weighted average of the two halves.  Floored halfway point is >>> 1.
          //Mutate the array while we get that slice so that we can just pass it again.
          //Weighted average is of form [values],[weights];
          return math.weightedAverage(
           [ math.mean(arrCopy.splice(0,arrCopy.length >>> 1 )),
             math.mean(arrCopy)],
           [arr.length-arrCopy.length,arrCopy.length]);
        }
      }
    };

    // math.median([1,2,3,4])
    //   => 2.5
    //   TODO {}, [{}]
    math.median = function(arr) {
      arr = arr.slice(0); // create copy
      var middle = (arr.length + 1) / 2,
        sorted = math.sort(arr);
      return (sorted.length % 2) ? sorted[middle - 1] : (sorted[middle - 1.5] + sorted[middle - 0.5]) / 2;
    };

    // Mode / Modes
    // math.mode([2,2,3,3,15,4])
    //   => [2,3]
    // optionalFunction should return a string and can control clustering.
    math.mode = math.modes = function(array,optionalFunction) {
      var clusterFunction = optionalFunction || function(a) { return a.toString(); }
      var max = 0,
       mode = [],
       counted = lodash.countBy(array,clusterFunction);
       max = lodash.max(lodash.values(counted));
      lodash.forIn(counted, function(v,k){
        if(v === max) {
          mode.push(parseFloat(k));
        }
      });
      return mode;
    };
    
    // Power, exponent
    // math.pow(2,3)
    //   => 8
    math.pow = math.power = function(x, n) {
      if (lodash.isNumber(x)) {
        return Math.pow(x, n);
      }
      if (lodash.isArray(x)) {
        return lodash.map(x, function(i) { return lodash.pow(i, n); });
      }
    };

    // Round
    // math.round(12345.6789, 2)
    //   => 12345.68
    math.round = function(number, decimals) {
      return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);
    };

    // Scale to max value
    // math.scale(1,[2,5,10])
    //   => [ 0.2, 0.5, 1]
    math.scale = function(arr, max) {
      max = max || 1;
      var max0 = lodash.max(arr);
      return lodash.map(arr, function(i) { return i * (max / max0); });
    };

    // Slope between two points
    // math.slope([0,0],[1,2])
    //   => 2
    math.slope = function(x, y) {
      return (y[1] - x[1]) / (y[0] - x[0]);
    };

    // Numeric sort
    // math.sort([3,1,2])
    //   => [1,2,3]
    math.sort = function(arr) {
      return lodash.sortBy(arr, lodash.identity);
    };

     // math.stdDeviation([1,2,3])
    //   => 0.816496580927726
    math.stdDeviation = math.sigma = function(arr) {
      return Math.sqrt(lodash.variance(arr));
    };

    // Sum of array
    // math.sum([1,2,3])
    //   => 6
    // math.sum([{b: 4},{b: 5},{b: 6}], 'b')
    //   => 15
    var internalSum = function(obj, key) {
      var arr = objKey2Array(obj,key),
       val = 0;
      for (var i = 0; i < arr.length; i++) {
        var nextValue = arr[i]-0;
        if(val > 0 && nextValue > Number.MAX_VALUE - val) {
          throw new Error('Overflow');
        }
        if(val < 0 && nextValue < Number.MIN_VALUE - val) {
          throw new Error('Underflow');
        }
        val += nextValue;
      }
      return val;
    };
    
    if(lodash.sum === undefined) {
     math.sum = internalSum;
    }

    // math.transpose(([1,2,3], [4,5,6], [7,8,9]])
    //   => [[1,4,7], [2,5,8], [3,6,9]]
    math.transpose = function(arr) {
      var trans = [];
      lodash.each(arr, function(row, y){
        lodash.each(row, function(col, x){
          if (!trans[x]) trans[x] = [];
          trans[x][y] = col;
        });
      });
      return trans;
    };

    // math.variance([1,2,3])
    //   => 2/3
    math.variance = function(arr) {
      var mean = lodash.mean(arr),
        variance = function(x) { return lodash.pow( x - mean, 2); };
      return lodash(arr).map(variance).mean().value();
    };

    // Standard score, assuming normal distribution
    // math.zscore([1,2,3])
    //   => [-1.224744871391589, 0, 1.224744871391589]
    math.zscore = function(obj, key) {
      var arr = objKey2Array(obj,key);

      var mean = lodash.mean(arr),
          sigma = lodash.stdDeviation(arr),
          zscore = function(d) { return (d - mean) / sigma; };
      return lodash.map(arr, zscore);
    };

    // math.movingAvg([1,2,3,4,5], 3);
    //   => [2,3,4]
    math.movingAvg = math.movingAverage = function(arr, size) {
      var win, i, newarr = [];
      for(i = size-1; i <= arr.length; i++) {
        win = arr.slice(i - size, i);
        if (win.length === size) {
          newarr.push(lodash.mean(win));
        }
      }
      return newarr;
    };
    
    math.shannon = function(obj,key) {
     var array = objKey2Array(obj,key),
      counts = lodash.values(lodash.countBy(array));
     return (Math.log(array.length) - lodash.sum(lodash.map(counts,function (n) {
                                                               return n*Math.log(n);
                                      }))/array.length
            )/Math.log(2);
    };
    
    //More safe with huge data sequences.
    //This is more theoretical because x*ln|x| is nearly linear.
    //As long as you don't have data with ~10^305 symbols you're good to use the faster one.
    //Well log10(number of symbols) + log10(number of kinds of symbols) should stay a margin away from 305 or we will go over 10^308 somewhere. 
    math.shannon2 = function(obj,key) {
     var array = objKey2Array(obj,key),
      counts = lodash.values(lodash.countBy(array));
     return -lodash.sum(
       lodash.map(
         lodash.map(
           counts,
           function(item) {
             return item/array.length;
           }),
         function(item) {
           return item*Math.log(item)/Math.log(2);
         }));
    };
    
    math.shannonMinimumBits = function(obj,key) {
     var array = objKey2Array(obj,key),
      counts = lodash.values(lodash.countBy(array));
     return (array.length*Math.log(array.length) - lodash.sum(lodash.map(counts,function (n) {
                                                               return n*Math.log(n);
                                                   }))
            )/Math.log(2);
    };
    

    // add methods to Underscore.js namespace
    
    lodash.mixin(math);
    return lodash;
  }

  if(window !== undefined) {
    mixin_loader(_);
  }
  else {
    module.exports = mixin_loader;
  }
})();


            Rally.launchApp('CustomApp', {
                name:"cycletimebystate",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>

    <style type="text/css">
        table.pvtTable {
  font-family: arial;
  font-size: 8pt;
  text-align: left;
  border-collapse: collapse;
}
table.pvtTable tr th,
table.pvtTable tr th {
  background-color: #e6EEEE;
  border: 1px solid #CDCDCD;
  font-size: 8pt;
  padding: 5px;
}
table.pvtTable .pvtColLabel {
  text-align: center;
}
table.pvtTable .pvtTotalLabel {
  text-align: right;
}
table.pvtTable tr td {
  color: #3D3D3D;
  padding: 5px;
  background-color: #FFF;
  border: 1px solid #CDCDCD;
  vertical-align: top;
  text-align: right;
}
.pvtTotal,
.pvtGrandTotal {
  font-weight: bold;
}
.pvtAxisContainer {
  border: 1px solid gray;
  background: #EEE;
  padding: 5px;
  min-width: 20px;
  min-height: 20px;
}
.pvtAxisContainer li {
  padding: 8px 6px;
  list-style-type: none;
  cursor: move;
}
.pvtAxisContainer li.placeholder {
  -webkit-border-radius: 5px;
  padding: 3px 15px;
  -moz-border-radius: 5px;
  border-radius: 5px;
  border: 1px dashed #aaa;
}
.pvtAxisContainer li nobr {
  background: #F3F3F3;
  border: 1px solid #DEDEDE;
  padding: 2px 5px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
.pvtTriangle {
  cursor: pointer;
  color: grey;
}
.pvtHorizList li {
  display: inline;
}
.pvtFilteredAttribute {
  font-style: italic;
}

    </style>
</head>
<body>
</body>
</html>
